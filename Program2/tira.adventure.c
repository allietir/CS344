/************************************************************
Assignment 2
Name: Alexander Tir
onid: tira
Description: This program is a text-driven adventure game in which the player explores
rooms until they reach the final room. The rooms are randomly generated using
tira.buildrooms.c, and this program will always use the most recently generated
set of rooms. The player follows the prompts until they complete the game, but
they may also enter "time" to print the current time. This program also utilizes
multithreading and mutexes in order to return the time.
************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <unistd.h>
#include <pthread.h>

#define NUM_ROOMS 7
#define MIN_CONNECT 3
#define MAX_CONNECT 6

//global thread variables
pthread_t thread_time;
pthread_mutex_t lock;

//Used to store information for a Room
struct Room
{
	int id;
	char* name;
	//Used to be enum in tira.buildrooms.c, but changed to char so that I can print immediately
	char* roomType;
	int connections;
	//Used to be an array of ints that stored each room's ID. Instead we will store each room's name as the connection.
	char roomConnections[MAX_CONNECT][16];
};


//This function retuens a pointer to the newest directory with the prefix "tira.buildrooms."
char *getNewestDirectory()
{
	//Taken from lecture on manipulating directories
	//I attempted to add more comments to reinforce my understanding of it
	//and that I am not just copying it.

	//initialize timestamp
	int newestTime = -1;
	//prefix of directory
	char dirPrefix[32] = "tira.buildrooms.";
	//holds name of newest directory
	char *newestDirName = malloc(sizeof(char) * 128);
	memset(newestDirName, '\0', sizeof(newestDirName));

	//initialize and return a pointer to current directory
	DIR *dir = opendir (".");
	//will hold the current sub directory of the starting directory
	struct dirent *fileInDir;
	//will hold directory attributes
	struct stat attributes; 

	if (dir != NULL)
	{
		//check every entry in dir
		while ((fileInDir = readdir(dir)) != NULL)
		{
			//strstr() finds the first occurence of the second argument in the first argument
			//in this case, a directory with the defined prefix
			if (strstr(fileInDir->d_name, dirPrefix) != NULL )
			{
				//call stat to retrieve attributes
				stat(fileInDir->d_name, &attributes);

				//if the time is more recent
				if ((int)attributes.st_mtime > newestTime)
				{
					//store newest time
					newestTime = (int)attributes.st_mtime;
					//refill block of memory with \0 before storing directory name
					memset(newestDirName, '\0', sizeof(newestDirName));
					strcpy(newestDirName, fileInDir->d_name);
				}
			}
		}
	}

	//close the opened directory
	closedir(dir);

	return newestDirName;
}

//This function loads the rooms by reading the room files generated by tira.buildrooms.c
//It iterates through each file and loads it into an array of pointers to Room structs.
void loadRooms(struct Room *roomList[])
{
	int i;
	int lineTracker;
	FILE *fp;

	//get name of newest directory
	char *roomDirectory = getNewestDirectory();
	
	//array for storying filepaths
	char roomFile[NUM_ROOMS][128];

	//the following is similar to what I implemented in getNewestDirector()
	//the biggest difference is that I am now storing the filepaths for later use
	struct dirent *fileInDir;
	DIR *roomDir = opendir(roomDirectory);

	i = 0;
	if (roomDir != NULL)
	{
		while ((fileInDir = readdir(roomDir)) != NULL)
		{
			//We do not need to include the relative directories
			//strcmp will return 0 if there is a match
			if(strcmp(fileInDir->d_name, "..") == 0 || strcmp(fileInDir->d_name, ".") == 0)
			{
				continue;
			}

			//store filepath as string
			sprintf(roomFile[i], "./%s/%s", roomDirectory, fileInDir->d_name);
			//printf("%s", roomFile[i]);
			
			i++;
		}
	}

	//now we load each Room
	//we are going to process one file at a time
	for (i = 0; i < NUM_ROOMS; i++)
	{
		//open file for reading
		fp = fopen(roomFile[i], "r");

		if (fp == NULL)
		{
			perror("Error opening file: ");
			exit(1);
		}
		
		//found on geeksforgeeks, we will extract a character from the file until we reach the end
		//every time a newline character is encountered, we will increment the line count by 1
		char c;
		int lineCount = 0;
		for (c = getc(fp); c != EOF; c = getc(fp))
		{
			if (c == '\n')
			{
				lineCount++;
			}
		}

		//rather than closing and reopening the file, we can reset the file pointer
		//to the start of the file using this
		rewind(fp);

		//line buffer
		char readLine[128];
		//3rd column buffer
		char column[16];

		//reset line tracker
		lineTracker = 0;

		//since we know the format of the files, we can read the file knowing what to expect
		//we start by using fgets to read a string that has spaces
		while(fgets(readLine, sizeof(readLine), fp) != NULL)
		{
			//we only need the 3rd "column" of chars
			sscanf(readLine, "%*s %*s %s", column);

			//the first line is the name of the room
			if (lineTracker == 0)
			{
				strcpy(roomList[i]->name, column);
			}
			//the last line is the type of the room
			else if (lineTracker == lineCount - 1)
			{
				strcpy(roomList[i]->roomType, column);
			}
			//any other line is a connection
			else
			{
				strcpy(roomList[i]->roomConnections[lineTracker - 1], column);
				//printf("%s\n", roomList[i]->roomConnections[lineTracker - 1]);
				roomList[i]->connections++;
			}

			lineTracker++;
		}

		roomList[i]->id = i;

		fclose(fp);
	}

	//at this point, all rooms should be loaded and the game ready to start
}

//This function gets the current time and writes it to a file in a format
//specified by strftime. This resource was given to us to use.
void *getTime()
{
	//attempt to lock mutex if available
	pthread_mutex_lock(&lock);

	//declare file pointer
	FILE *fp;
	//time variable and objects
	time_t currentTime;
	struct tm *tmp;

	//char buffer to hold written time
	char writeTime[128];

	//store current time
	currentTime = time(NULL);
	tmp = localtime(&currentTime);

	//Format can be found here: https://linux.die.net/man/3/strftime
	strftime(writeTime, sizeof(writeTime), "%l:%M%P, %A, %B %d, %Y\n", tmp);

	fp = fopen("currentTime.txt", "w");
	fprintf(fp, writeTime);

	//close file
	fclose(fp);

	//unlock mutex
	pthread_mutex_unlock(&lock);
}

//This function reads the currentTime.txt file and prints the time written there
void printTime()
{
	//file pointer
	FILE *fp;
	//buffer to hold time to print
	char printBuffer[128];

	//open time file
	fp = fopen("currentTime.txt", "r");

	//read in the time using the buffer
	fgets(printBuffer, sizeof(printBuffer), fp);

	//print the time to user
	printf("\n%s\n", printBuffer);

	//close file
	fclose(fp);
}

//This function starts the game. The game can only be started after all rooms are loaded.
void startGame(struct Room *roomList[])
{
	int i;
	int j;
	int stepCount = 0;
	int gameOver = 0;
	int valid;
	char input[16];
	//stores the path, user cannot exceed 100 steps to reach end room
	char path[100][16];

	//initialize struct to hold current room
	struct Room *currentRoom = (struct Room*) malloc(sizeof(struct Room));
	currentRoom->name = calloc(16, sizeof(char));
	currentRoom->roomType = calloc(16, sizeof(char));

	//first we must find the start room
	for (i = 0; i < NUM_ROOMS; i++)
	{
		if (strcmp(roomList[i]->roomType, "START_ROOM") == 0)
		{
			currentRoom = roomList[i];
			break;
		}
	}

	do{
		//reset flag
		valid = -1;

		//print room according to assignment format
		printf("CURRENT LOCATION: %s\n", currentRoom->name);
		printf("POSSIBLE CONNECTIONS: ");
		for (j = 0; j < currentRoom->connections; j++)
		{
			//if last room connection, print a period
			if (j == currentRoom->connections - 1)
			{
				printf("%s.\n", currentRoom->roomConnections[j]);
			}
			//otherwise, separate by commas
			else
			{
				printf("%s, ", currentRoom->roomConnections[j]);
			}
		}

		input:
		//prompt user for input
		printf("WHERE TO? >");
		//store input into buffer
		scanf("%s", input);

		//if the user enters "time", the mutex will unlock, allowing getTime to execute
		//current thread will wait for getTime to finish executing before continuing		
		if (strcmp(input, "time") == 0)
		{
			//unlock the mutex
			pthread_mutex_unlock(&lock);

			//wait for thread_time to finish, then join
			pthread_join(thread_time, NULL);

			//lock the mutex
			pthread_mutex_lock(&lock);

			//spawn thread again since the first will stop existing after the join
			pthread_create(&thread_time, NULL, getTime, NULL);

			//print the time to user
			printTime();
			
			goto input;
		}

		//check user entered a valid room name
		for (j = 0; j < currentRoom->connections; j++)
		{	
			if (strcmp(input, currentRoom->roomConnections[j]) == 0)
			{
				printf("\n");
				valid = 1;
				break;
			}
		}

		//go back to start of loop if input was invalid
		if (valid != 1)
		{
			//if room name is invalid, shout at user and try again
			printf("\nHUH? I DON'T UNDERSTAND THAT ROOM. TRY AGAIN.\n\n");
			continue;
		}
		else if (valid == 1)
		{
			//load the next room
			for (j = 0; j < NUM_ROOMS; j++)
			{
				//by matching the name to the input
				if (strcmp(input, roomList[j]->name) == 0)
				{
					currentRoom = roomList[j];

					//store path, we do not include the starting room
					strcpy(path[stepCount], currentRoom->name);

					break;
				}
			}

			//increment step count
			stepCount++;
		}

		//check for game over, don't forget to store the room to path
		if (strcmp(currentRoom->roomType, "END_ROOM") == 0)
		{
			strcpy(path[stepCount], currentRoom->name);
			gameOver = 1;
		}
		//check for limit of 100 step counts
		else if (stepCount >= 99)
		{
			printf("\nTOO MANY STEPS. EXITING GAME.\n");
			exit(1);
		}

	} while (gameOver != 1);

	printf("YOU HAVE FOUND THE END ROOM. CONGRATULATIONS!\n");
	printf("YOU TOOK %d STEPS. YOUR PATH TO VICTORY WAS:\n", stepCount);

	//print path to victory
	for (i = 0; i < stepCount; i++)
	{
		printf("%s\n", path[i]);
	}
}

//The main function, drives the program. It initializes a mutex and immediately locks it.
//A thread is created for getTime().
//The rooms are loaded before startGame() is called.
int main()
{
	int i;

	//initialize an array of pointers to Room structs
	struct Room *roomList[NUM_ROOMS];

	//allocate memory for each Room in roomList
	for (i = 0; i < NUM_ROOMS; i++)
	{
		//allocate memory for each Room
		roomList[i] = (struct Room*) malloc(sizeof(struct Room));

		//Only allocating memory, not assigning yet
		roomList[i]->name = calloc(16, sizeof(char));
		roomList[i]->roomType = calloc(16, sizeof(char));

		//starts at 0, will be incremented when a connection is added
		roomList[i]->connections = 0;
	}

	//load the rooms into roomList
	loadRooms(roomList);

	//initialize the mutex
	pthread_mutex_init(&lock, NULL);

	//lock the mutex immediately
	pthread_mutex_lock(&lock);

	//spawn the time thread
	//it will attempt to lock the mutex, but cannot yet until it is unlocked when
	//"time" is inputted into the game function
	pthread_create(&thread_time, NULL, getTime, NULL);

	//start the game
	startGame(roomList);

	//unlock the mutex
	pthread_mutex_unlock(&lock);
	//destroy the mutex
	pthread_mutex_destroy(&lock);

	//free allocated memory
	for (i = 0; i < NUM_ROOMS; i++)
	{
		free(roomList[i]);
	}

	return 0;
}